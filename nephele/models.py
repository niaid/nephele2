"""
Utility functions for views.
"""

import os
import json
import traceback
import logging
import fnmatch
import sh
from werkzeug.utils import secure_filename
from nephele2.nephele.upload_file import uploadfile
from nephele2.infra.utils.map_validator import MapType

LOGGER = logging.getLogger()


def get_remote_file_list(job_base_dir, allowed_file_exts):
    """
    Gets a list of all file names with the allowed extensions from a
    .listing file generated by wget.  Note, if the structure of the .listing
    file ever changes, this method will fail.

    Args:
        job_base_dir (str): the directory path where the .listing file is
        located allowed_file_exts (str): set of allowed file extensions

    Returns:
        list: a list of filename strings

    Raises:
        Exception: any exception generated while trying to read the .listing
        file
    """
    try:
        # get the list from the .listing file
        # awk '{out=""; for(i=9;i<=NF;i++){out=out" "$i}; print out}'
        # ~/Projects/tmp/.listing
        f_list = sh.awk(
            '{out=""; for(i=9;i<=NF;i++){out=out" "$i}; print out}',
            job_base_dir+'.listing')
        files = []
        for f_name in f_list:
            files.append(f_name.strip())
        allowed_exts = ["*."+str(e) for e in list(allowed_file_exts)]
        file_list = []
        for ext in allowed_exts:
            for f_name in fnmatch.filter(files, ext):
                file_list.append(f_name)
        return file_list
    except BaseException:
        LOGGER.error(
            "Error getting file names from .listing file at " +
            str(job_base_dir + '.listing') + "\n" + str(traceback.format_exc()))
        raise


def get_filename_from_path(url_path):
    """
    Extracts a filename from the end of a URL that points to the file.

    Args:
        url_path (url): a URL pointing to a file

    Returns:
        ASCII str: a secure filename
    """
    try:
        path = url_path.rsplit('/', 1)[1]
        return secure_filename(path)
    except Exception:
        LOGGER.error("Error parsing file URL "+str(url_path) +
                     "\n" + str(traceback.format_exc()))
        raise


def get_non_job_argslist(details_form):
    """
    Gets a list of all fields returned with the Job options forms that
    shouldn't be included in the job args list put in the database.

    Args:
        details_form (WTForm): the JobDetails form (a form that is
                               used as a base for most other job
                               options forms)

    Returns:
        list: list of arguments to remove from the job_args list
    """
    details_list = ['csrf_token', 'start_job']
    for fieldname, value in details_form.data.items():
        details_list.append(fieldname)
    return details_list

# TODO: we could move this down into the job_type table in the DB
# if we want to store all info about a job in one place


def get_analysis_type(data_type):
    """
    Return the MapType associated with the data type.

    Args:
        data_type (str): The type of sequence data being provided

    Returns:
        MapType: The MapType associated with the data type
    """
    if data_type == "SE":
        analysis = MapType.SE_DEMULTIPLEX
    elif data_type in ["PE", "ITS_PE"]:
        analysis = MapType.PAIRED_END
    elif data_type == "WGS_PE":
        analysis = MapType.PE_WGS
    elif data_type == "WGS_SE":
        analysis = MapType.SE_WGS
    elif data_type == "QC_PE":
        analysis = MapType.PE_QC
    elif data_type == "QC_SE":
        analysis = MapType.SE_QC
    elif data_type == "DS_Analysis":
        analysis = MapType.DS_ANALYSIS
    else:
        analysis = MapType.STANDARD
    return analysis

def get_column_map(table_data):
    col_map = {}
    for row in table_data:
        for col_label in row:
            col_map.setdefault(col_label, []).append(row[col_label])
    return col_map

##### BLUEIMP STUFF #####

# TODO: see if we can get blueimp to play nice with WTF so we can get rid of
# this


def allowed_file(filename, allowed_exts):
    """
    The validator for blueimp that limits which file extensions are allowed.

    Args:
        filename (str): a filepath
        allowed_exts (str): set of allowed file extensions

    Returns:
        bool: True if extension is an allowed file type, False otherwise
    """
    allowed_extensions = ["*."+str(e) for e in list(allowed_exts)]
    for ext in allowed_extensions:
        if fnmatch.fnmatch(filename.lower(), ext):
            return True
    return False


def get_file_list(uniq_dname):
    """
    Returns a list of files in the directory.  Required to return
    a JSON by blueimp.

    Args:
        uniq_dname (str): filepath to the directory to query

    Returns:
        JSON: a JSON structured like '{"files": [list_of_filepaths]}'
    """
    file_display = []
    try:
        files = [f for f in os.listdir(uniq_dname) if os.path.isfile(
            os.path.join(uniq_dname, f))]

        for f in files:
            size = os.path.getsize(os.path.join(uniq_dname, f))
            file_saved = uploadfile(name=f, size=size)
            file_display.append(file_saved.get_file())

        return json.dumps({"files": file_display})
    except OSError:
        LOGGER.error("Error while getting the list of files in dir "
                     + str(uniq_dname)+": "+str(traceback.format_exc()))
        # This could be a FileNotFound err from the dir not existing,
        # or a PermissionError thrown from the getsize call
        # TODO: decide if this is the right thing to do,
        # it will just return whatever it's found so far
        return json.dumps({"files": file_display})


def save_file(dirname, files, allowed_exts):
    """
    Save file function called by blueimp.  Must return a JSON of the list of
    upload_file objects that were saved, or failed to save.

    Args:
        dirname (str): The path to the directory where the files
            should be saved
        files (str): name of the file to save
        data_type (str): the data_type of the file (from the HTML header)

    Returns:
        JSON: a JSON string that looks like {"files": [uploadfile().get_file()]}
    """
    try:
        filename = secure_filename(files.filename)
        mime_type = files.content_type

        if not allowed_file(files.filename, allowed_exts):
            result = uploadfile(name=filename,
                                type=mime_type,
                                size=0,
                                not_allowed_msg="File type not allowed")
        else:
            # save file to disk
            uploaded_file_path = os.path.join(dirname, filename)
            files.save(uploaded_file_path)
            os.chmod(uploaded_file_path, 0o666)  # chmod a-x

            # get file size after saving
            size = os.path.getsize(uploaded_file_path)

            # return json for js call back
            result = uploadfile(name=filename, type=mime_type, size=size)

        return json.dumps({"files": [result.get_file()]})
    except FileNotFoundError:
        LOGGER.error("File not found "+str(traceback.format_exc()))
        result = uploadfile(name=files.filename,
                            type=files.content_type,
                            size=0,
                            not_allowed_msg="INTERNAL SERVER ERROR")
        return json.dumps({"files": [result.get_file()]})
    except Exception:
        LOGGER.error("Could not save file " + str(traceback.format_exc()))
        result = uploadfile(name=files.filename,
                            type=files.content_type,
                            size=0,
                            not_allowed_msg="INTERNAL SERVER ERROR")
        return json.dumps({"files": [result.get_file()]})


def delete_file(dirname, filename):
    """
    Deletes a file from a given directory.
    This method is used by blueimp and is required
    to return a JSON with the structure {<filename>: is_deleted}.

    Args:
        dirname (str): path of the directory the file should be removed from
        filename (str): name of the file to delete

    Returns:
        JSON: a JSON with the name of the file and a boolean indication of
        whether or not it was deleted
    """
    file_path = os.path.join(dirname, filename)

    if os.path.exists(file_path):
        try:
            os.remove(file_path)
            return json.dumps({filename: 'True'})
        except Exception:
            return json.dumps({filename: 'False'})
    return json.dumps({filename: 'False'})
